import { Client, PoolClient } from 'pg';
import logger from '../logger.js';
import { getClient } from './index.js'

async function createPuzzleChainsTable(client: Client | PoolClient) {
	const query = [""
		, "CREATE TABLE IF NOT EXISTS puzzle_chains("
		, "	id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,"
		, "	guild_id VARCHAR(127) NOT NULL,"
		, "	generated_ts TIMESTAMPTZ NOT NULL DEFAULT now(),"
		, "	closed_ts TIMESTAMPTZ DEFAULT NULL"
		, ");"
	].join(' ');

	const functionQuery = [""
		, "CREATE OR REPLACE FUNCTION get_or_create_puzzle_chain(p_guild_id TEXT)"
		, "RETURNS puzzle_chains AS $$"
		, "DECLARE"
		, "	result_row puzzle_chains%ROWTYPE;"
		, "BEGIN"
		, "	SELECT * INTO result_row "
		, "	FROM puzzle_chains"
		, "	WHERE guild_id = p_guild_id"
		, "	AND closed_ts IS NULL;"

		, "	IF NOT FOUND THEN"
		, "		INSERT INTO puzzle_chains(guild_id)"
		, "		VALUES (p_guild_id)"
		, "		RETURNING * INTO result_row;"
		, "	END IF;"

		, "	RETURN result_row;"
		, "END;"
		, "$$ LANGUAGE plpgsql;"
	].join(' ');

	await client.query(query);
	await client.query(functionQuery);
}

async function createPuzzlesTable(client: Client | PoolClient) {
	const query = [""
		, "CREATE TABLE IF NOT EXISTS puzzles("
		, "	id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,"
		, "	puzzle_chain_id INT NOT NULL REFERENCES puzzle_chains(id),"
		, "	question VARCHAR(4095) NOT NULL,"
		, "	answer VARCHAR(4095) NOT NULL,"
		, "	index INT NOT NULL,"
		, "	generated_ts TIMESTAMPTZ NOT NULL DEFAULT now(),"
		, "	UNIQUE(puzzle_chain_id, index)"
		, ");"
	].join(' ');

	const triggerFunctionQuery = [""
		, "CREATE OR REPLACE FUNCTION set_puzzle_index()"
		, "RETURNS TRIGGER"
		, "LANGUAGE PLPGSQL"
		, "AS"
		, "$$"
		, "DECLARE"
		, "	next_index INT;"
		, "	new_puzzle_chain_id INT;"
		, "BEGIN"
		, "	SELECT COALESCE(MAX(index), 0) + 1 FROM puzzles"
		, "	WHERE puzzle_chain_id = NEW.puzzle_chain_id"
		, "	INTO next_index;"

		, "	NEW.index := next_index;"
		, "	RETURN NEW;"
		, "END;"
		, "$$;"
	].join(' ');

	const triggerQuery = [""
		, "CREATE OR REPLACE TRIGGER puzzles_before_insert"
		, "BEFORE INSERT"
		, "ON puzzles"
		, "FOR EACH ROW"
		, "EXECUTE FUNCTION set_puzzle_index();"
	].join(' ');

	await client.query(query);
	await client.query(triggerFunctionQuery);
	await client.query(triggerQuery);
}

async function createAnswersTable(client: Client | PoolClient) {
	const query = [""
		, "CREATE TABLE IF NOT EXISTS answers("
		, "	id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,"
		, "	puzzle_id INT NOT NULL REFERENCES puzzles(id),"
		, "	user_id VARCHAR(127) NOT NULL,"
		, "	completed_ts TIMESTAMPTZ NOT NULL DEFAULT now(),"
		, "	UNIQUE(puzzle_id, user_id)"
		, ");"
	].join(' ');

	await client.query(query);
}

export async function initTables() {
	const client = await getClient();
	try {

		await client.query('BEGIN');

		await createPuzzleChainsTable(client);
		logger.info('Successfully created puzzle_chains table.');

		await createPuzzlesTable(client);
		logger.info('Successfully created puzzles table.');

		await createAnswersTable(client);
		logger.info('Successfully created answers table.');

		await client.query('COMMIT');
	} catch (error) {
		logger.error(`Could not create tables: ${error}`);
		await client.query('ROLLBACK');

		throw error;
	} finally {
		client.release();
	}
}
