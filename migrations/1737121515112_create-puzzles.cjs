/**
 * @type {import('node-pg-migrate').ColumnDefinitions | undefined}
 */
exports.shorthands = undefined;

/**
 * @param pgm {import('node-pg-migrate').MigrationBuilder}
 * @param run {() => void | undefined}
 * @returns {Promise<void> | void}
 */
exports.up = (pgm) => {
	pgm.sql(`
		CREATE TABLE IF NOT EXISTS puzzles(
			id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
			puzzle_chain_id INT NOT NULL REFERENCES puzzle_chains(id),
			question VARCHAR(4095) NOT NULL,
			answer VARCHAR(4095) NOT NULL,
			index INT NOT NULL,
			generated_ts TIMESTAMPTZ NOT NULL DEFAULT now(),
			UNIQUE(puzzle_chain_id, index)
		);
	`);

	pgm.sql(`
		CREATE OR REPLACE FUNCTION set_puzzle_index()
		RETURNS TRIGGER
		LANGUAGE PLPGSQL
		AS
		$$
		DECLARE
			next_index INT;
			new_puzzle_chain_id INT;
		BEGIN
			SELECT COALESCE(MAX(index), 0) + 1 FROM puzzles
			WHERE puzzle_chain_id = NEW.puzzle_chain_id
			INTO next_index;

			NEW.index := next_index;
			RETURN NEW;
		END;
		$$;
	`);

	pgm.sql(`
		CREATE OR REPLACE TRIGGER puzzles_before_insert
		BEFORE INSERT
		ON puzzles
		FOR EACH ROW
		EXECUTE FUNCTION set_puzzle_index();
	`);
};

/**
 * @param pgm {import('node-pg-migrate').MigrationBuilder}
 * @param run {() => void | undefined}
 * @returns {Promise<void> | void}
 */
exports.down = (pgm) => {
	// Drop the trigger
	pgm.sql(`DROP TRIGGER IF EXISTS puzzles_before_insert ON puzzles;`);

	// Drop the trigger function
	pgm.sql(`DROP FUNCTION IF EXISTS set_puzzle_index;`);

	// Drop the table
	pgm.dropTable('puzzles');
};
